/*

//////////////////////////TEAM//////////////////////////
BITS ID             Member Name
2020A7PS0073P       Shashank Agrawal
2020A7PS0096P       Akshat Gupta
2020A7PS0129P       Anish Ghule
2020A7PS0134P       Shadan Hussain
2020A7PS1513P       Tarak P V S

*/

#ifndef LEXER_H
#define LEXER_H

#include "hashmap.h"
#include<stdbool.h>
#include<stdio.h>

/* TYPE DEFINITIONS */

typedef enum TOKEN
{
    ID,
    NUM,
    RNUM,
    GT,
    ENDDEF,
    DRIVERENDDEF,
    GE,
    LT,
    DEF,
    DRIVERDEF,
    LE,
    PLUS,
    MINUS,
    MUL,
    DIV,
    COLON,
    ASSIGNOP,
    EQ,
    NE,
    RANGEOP,
    SEMICOL,
    COMMA,
    SQBO,
    SQBC,
    BO,
    BC,
    TRUE,
    FALSE,
    AND,
    OR,
    INTEGER,
    REAL,
    BOOLEAN,
    OF,
    ARRAY,
    START_TK,
    END,
    DECLARE,
    MODULE,
    DRIVER,
    PROGRAM,
    GET_VALUE,
    PRINT,
    USE,
    WITH,
    PARAMETERS,
    TAKES,
    INPUT,
    RETURNS,
    FOR,
    IN,
    SWITCH,
    CASE,
    BREAK,
    DEFAULT,
    WHILE,
    DOLLAR,
    EPSILON
} TOKEN;

// Union to store Integer/Boolean/Float Data if present in a lexeme
typedef union tokenDataUnion
{
    float ifFloat;
    int ifInt;
    bool ifBool;
} tokenDataUnion;

// Struct to store token info
typedef struct tokenInfo
{
    TOKEN tokenType;
    char lexeme[20];
    tokenDataUnion tokenData;
    int lineNo;
} tokenInfo;

// enum storing all states for DFA
typedef enum STATE
{
    START,
    S1,
    S2,
    S3,
    S4,
    S5,
    S6,
    S7,
    S8,
    S9,
    S10,
    S11,
    S12,
    S13,
    S14,
    S15,
    S16,
    S17,
    S18,
    S19,
    S20,
    S21,
    S22,
    S23,
    S24,
    S25,
    S26,
    S27,
    S28,
    S29,
    S30,
    S31,
    S32,
    S33,
    S34,
    S35,
    S36,
    S37,
    S38,
    S39,
    TRAP
} STATE;

typedef enum STATE STATE;
// returns the token type in string form
// used while printing tokens generated by the parser
char *getTokenName();

// function implementing lookup table
TOKEN lookupToken(char *idStr);

// runs DFA and decides next state
enum STATE start(char c);
enum STATE s1(char c);
enum STATE s2(char c);
enum STATE s3(char c);
enum STATE s4(char c);
enum STATE s5(char c);
enum STATE s6(char c);
enum STATE s7(char c);
enum STATE s8(char c);
enum STATE s9(char c);
enum STATE s10(char c);
enum STATE s11(char c);
enum STATE s12(char c);
enum STATE s13(char c);
enum STATE s14(char c);
enum STATE s15(char c);
enum STATE s16(char c);
enum STATE s17(char c);
enum STATE s18(char c);
enum STATE s19(char c);
enum STATE s20(char c);
enum STATE s21(char c);
enum STATE s22(char c);
enum STATE s23(char c);
enum STATE s24(char c);
enum STATE s25(char c);
enum STATE s26(char c);
enum STATE s27(char c);
enum STATE s28(char c);
enum STATE s29(char c);
enum STATE s30(char c);
enum STATE s31(char c);
enum STATE s32(char c);
enum STATE s33(char c);
enum STATE s34(char c);
enum STATE s35(char c);
enum STATE s36(char c);
enum STATE s37(char c);
enum STATE s38(char c);
enum STATE s39(char c);
enum STATE trap(char c);

// Functions
enum STATE nextState(enum STATE state, char c);

// populates buffer from file
void populateBuffer(FILE *fp, char *buff);

// To get next Token
tokenInfo *getNextToken(FILE *fp);

// creates and returns a new token
tokenInfo *addNewToken(char *buff1, char *buff2, int begin, int forward, STATE finalState);

// returns the string corresponding to the type of token
char *getTokenName(TOKEN tokenType);

// lookup table
HashmapEntry *initializeLookupTable();

TOKEN lookupToken(char *idStr);

void printAllTokens(char* fileName, int bufferSize);

void initializeGlobals();

#endif /* LEXER_H */